----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date:    14:32:19 01/16/2015 
-- Design Name: 
-- Module Name:    Merge_template - Behavioral 
-- Project Name: 
-- Target Devices: 
-- Tool versions: 
-- Description: 
--
-- Dependencies: 
--
-- Revision: 
-- Revision 0.01 - File Created
-- Additional Comments: 
--
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
library UNISIM;
use UNISIM.VComponents.all;
-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity Template_Merge is

end Template_Merge;

architecture Behavioral of Template_Merge is

signal counter  : std_logic_vector(16 downto 0);
signal counter2  : std_logic_vector(3 downto 0);
-- Defining all the Components
Component DAC_interface is
	port(
		-- on board signals
		Sys_Rst_pin				:	in std_logic;
		Clk_Locked_pin			:	out std_logic;	
		Switch					: 	in std_logic_vector(1 downto 0);
		S_Phase					: 	in std_logic_vector(2 downto 0);
		amplitude				: 	in std_logic_vector(2 downto 0);
		-- data_out					:	inout std_logic_vector(15 downto 0);
		-- signals to DAC
		Dac_Sync_p				: 	out std_logic;
		Dac_Sync_n				:	out std_logic;
		Dac_Data_clk_p_pin	:	out std_logic;
		Dac_Data_clk_n_pin	:	out std_logic;
		Dac_Data_out_p_pin	:	out std_logic_vector(15 downto 0);
		Dac_Data_out_n_pin	:	out std_logic_vector(15 downto 0);
		-- signals from DAC
		Dac_FPGA_clk_p_pin	:	in std_logic;
		Dac_FPGA_clk_n_pin	:	in std_logic;
		-- signals from ADC
		Data_in_clk				:	in std_logic;
		Data_rising				:	in std_logic_vector(15 downto 0);
		Data_falling			:	in std_logic_vector(15 downto 0));
		
end Component;

Component Gauss is
		port(
		clk 			: in STD_LOGIC;
		reset 		: in STD_LOGIC;
		amplitude 	: in std_logic_vector(2 downto 0);
		PhaseInc		: in std_logic_vector(4 downto 0);
		Gauss_env	: out std_logic_vector(15 downto 0));
		
		
		end Component;
		
		
Component C-phase is 
		port(
		clk   	: in STD_LOGIC;
		reset		: in STD_LOGIC;
		QB1_sig	: out std_logic_vector(15 downto 0);
		QB2_sig	: out std_logic_vector(15 downto 0);
		anc_sig	: out std_logic_vector(15 downto 0));

	end Component;
	
	
-- encode qubits by entangling C-Phase
Component Parity_Cphase is
port (
run_parity : in std_logic; -- c-phase operation runs while this is "1"
clk : 		in std_logic;
QB1_sig : 	out std_logic_vector(15 downto 0)  -- QuBit1
QB2_sig : 	out std_logic_vector(15 downto 0)  -- QuBit2
anc_sig : 	out std_logic_vector(15 downto 0)  -- Ancilla
end Component;

Component Ancilla_readout is 
		port(
		clk				: in STD_LOGIC;
		reset				: in STD_LOGIC;
		data_in			: in std_logic_vector(11 downto 0);
		Ancilla_state	: out std_logic_vector(1 downto o));
		
end Component;

-- Defined All the components


Component ADC_top_level is
 port (
		Sys_Rst_pin					: in std_logic; 
		Sys_Clk_p_pin       		: in std_logic;     -- System 200 MHz clock to generate 50 MHz
		Sys_Clk_n_pin       		: in std_logic; 
		-- 50 MHz sampling clock for ADC
		Adc_Sampling_clk_p_pin		: out std_logic;
		Adc_Sampling_clk_n_pin		: out std_logic;
		-- Input data from ADC
		Adc_Bit_clk_p_pin			: in std_logic;         --Bit clk
		Adc_Bit_clk_n_pin			: in std_logic; 
		Adc_Frame_clk_p_pin			: in std_logic;         --Frame clk
		Adc_Frame_clk_n_pin			: in std_logic;
		Adc_Data_In_p_pin			: in std_logic_vector(7 downto 0);         --Data
		Adc_Data_In_n_pin			: in std_logic_vector(7 downto 0);
		
		-- Sampled data i frame clock - shouldn't go outside FPGA
		-- Comment for implementation and use for simulations and final project
		Int_data0					: out std_logic_vector(11 downto 0);
		Int_data1					: out std_logic_vector(11 downto 0);
		Int_data2					: out std_logic_vector(11 downto 0);
		Int_data3					: out std_logic_vector(11 downto 0);
		Int_data4					: out std_logic_vector(11 downto 0);
		Int_data5					: out std_logic_vector(11 downto 0);
		Int_data6					: out std_logic_vector(11 downto 0);
		Int_data7					: out std_logic_vector(11 downto 0);
		Int_Frame_clk_out			: out std_logic);

end Component;

Component Measurement is

end  Component;

begin --process(clk,reset) -- encode qubits (C-phase)
-- initializing qubit wait for 100 us, that is 100000 clock cycles

if reset = '1' then

elsif rising_edge(clk)	then
counter <= counter +1;
end if;

if counter = "11000011010100000" then

-- entangle/encoding qubit

 







Entangle: Parity_Cphase
port map (
run_parity 	=>	
clk 			=>
QB1_sig 		=>		-- QuBit1
QB2_sig 		=>  	-- QuBit2
anc_sig 		=>  	-- Ancilla


Singlequbitoperation	: Gauss
		port map(
			Rst			=> 
			Clk			=> 
			amplitude	=> 
			PhaseInc		=> 
			Gauss_env	=> 

Multiqubitoperation: Cphase
		port map(
			clk   	=>
			reset		=>
			QB1_sig	=> 
			QB2_sig	=> 
			anc_sig	=> );
			

			
Hadamard			:

Measurement : 

Ancillaread : 
		port map(
			clk				=> 
			reset				=>
			data_in			=>
			Ancilla_state	=>

applyentangle : DAC_interface 
	port map(
		-- on board signals
		Sys_Rst_pin				=>
		Clk_Locked_pin			=>			
	
		-- signals to DAC
		Dac_Sync_p				=> 	
		Dac_Sync_n				=>	
		Dac_Data_clk_p_pin	=>	
		Dac_Data_clk_n_pin	=>	
		Dac_Data_out_p_pin	=>	
		Dac_Data_out_n_pin	=>	
		-- signals from DAC
		Dac_FPGA_clk_p_pin	=>	
		Dac_FPGA_clk_n_pin	=>
		-- signals from ADC
		Data_in_clk				=> 
		Data_rising				=>	
		Data_falling			=>	
		16bitcommand			=> 
		



end Behavioral;


